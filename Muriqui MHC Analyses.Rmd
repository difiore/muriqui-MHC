---
title: "Muriqui MHC Analyses"
author: "Anthony Di Fiore"
date: "2023-05-06"
output: html_document
---

# Preliminaries
```{r Load Libraries}
library(here) # for current working directory
library(related) # for Queller-Goodnight R calculation
library(tidyverse) # for data wrangling
library(ggvenn) # for toy example Venn diagram
library(skimr) # for quick summary statistics
library(infer) # for `get_p_value()`
library(cowplot) # for creating multipanel plots
```

```{r Load and Process Genotype Data}
adults_genos <- readgenotypedata("data/adults_genos.txt")
all_genos <- readgenotypedata("data/all_genos.txt")
loci <- read_tsv("data/loci.txt", col_names = TRUE) # locus names in order presented in genotypes table
adults <- read_tsv("data/adults.txt", col_names = TRUE) # all adults names and sexes
males <- adults %>% filter(SEX == "M") %>% pull(ID)
females <- adults %>% filter(SEX == "F") %>% pull(ID)
seed <- 11539 # use the same random seed for each simulation to generate results for exact figures reported in paper. The seed can be anything! P values will change slightly, but results are unchanged.
```

# Relatedness

```{r Relatedness Estimate Calculations}
# Calculate estimated pairwise R
adults_rel <- coancestry(
  adults_genos$gdata,
  allow.inbreeding = FALSE,
  error.rates = 0.01,
  quellergt = 2,
  ritland = 0)
all_rel <- coancestry(
  all_genos$gdata,
  allow.inbreeding = FALSE,
  error.rates = 0.01,
  quellergt = 2,
  ritland = 0)

# Extract the pairwise R values and reformat columns
adults_pairwise_R <- adults_rel$relatedness %>%
  select(pair.no, ind1.id, ind2.id, quellergt)
all_pairwise_R <- all_rel$relatedness %>%
  select(pair.no, ind1.id, ind2.id, quellergt)
```

```{r Create Full Relatedness Matrices}
# Adults
# Create a list of all adult IDs
adults_id <- sort(unique(c(as.character(adults_pairwise_R$ind1.id), as.character(adults_pairwise_R$ind2.id))))

# Set up an empty matrix to hold pairwise R estimates
adults_R_matrix <- matrix(NA, nrow = length(adults_id), ncol = length(adults_id), dimnames = list(adults_id, adults_id))

# Fill the diagonal
diag(adults_R_matrix) <- 1 

# Fill the upper half of the matrix
adults_R_matrix[as.matrix(adults_pairwise_R[, c("ind1.id", "ind2.id")])] <- adults_pairwise_R[,c("quellergt")] # R values

# Fill the lower half of the matrix
adults_R_matrix[as.matrix(adults_pairwise_R[, c("ind2.id", "ind1.id")])] <- adults_pairwise_R[,c("quellergt")] # R values
# This is now a full dyadic R matrix of adults

# All individuals
# Create a list of all individual IDs
all_id <- sort(unique(c(as.character(all_pairwise_R$ind1.id), as.character(all_pairwise_R$ind2.id))))

# Set up an empty matrix to hold pairwise R estimates
all_R_matrix <- matrix(NA, nrow = length(all_id), ncol = length(all_id), dimnames = list(all_id, all_id))

# Fill the diagonal
diag(all_R_matrix) <- 1 

# Fill the upper half of the matrix
all_R_matrix[as.matrix(all_pairwise_R[, c("ind1.id", "ind2.id")])] <- all_pairwise_R[,c("quellergt")] # R values

# Fill the lower half of the matrix
all_R_matrix[as.matrix(all_pairwise_R[, c("ind2.id", "ind1.id")])] <- all_pairwise_R[,c("quellergt")] # R values
# This is now a full dyadic R matrix of all individuals

# # To save these data structures......
adults_R_matrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/adults_R_matrix.txt")
all_R_matrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/all_R_matrix.txt")
```

# Comparing Relatedness among Dyad Types in Adults

```{r Mean Relatedness by Dyad Type}
# Go back to pairwise R from {related} in long format, add in information on sex of each adult, and assign dyad type as male-male, female-female, or mixed sex

pairwise_R <- adults_pairwise_R %>%
  left_join(., adults, by = c("ind1.id" = "ID")) %>%
  left_join(., adults, by = c("ind2.id" = "ID")) %>%
  rename(ind1.sex = SEX.x, ind2.sex = SEX.y) %>%
  mutate(dyad.type = paste0(ind1.sex, ind2.sex)) %>%
  mutate(dyad.type = case_when(dyad.type == "MM" ~ "MM", # male-male
                               dyad.type == "FF" ~ "FF", # female-female
                               dyad.type == "MF" | dyad.type == "FM" ~ "MS")) # mixed sex
pairwise_R$dyad.type <- factor(pairwise_R$dyad.type, levels = c("FF", "MS", "MM")) # relevel for plotting

obs_R <- pairwise_R %>%
  group_by(dyad.type) %>%
  summarize(mean = mean(quellergt)) %>%
  pivot_wider(values_from = mean, names_from = dyad.type) %>%
  mutate(
    # Overall = mean(pairwise_R$quellergt),
    MM.FF.diff = MM - FF,
    MM.MS.diff = MM - MS,
    FF.MS.diff = FF - MS) %>%
  pivot_longer(everything()) %>%
  rename(dyad.type = name, obs.Mean.R = value)

obs_R$dyad.type <- factor(obs_R$dyad.type, levels = c("FF", "MS", "MM", "FF.MS.diff", "MM.MS.diff", "MM.FF.diff")) # relevel for plotting
```

```{r Plot Results}
p <- ggplot(pairwise_R, aes(x = dyad.type, y = quellergt)) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.5) +
  geom_boxplot(width = 0.4, alpha = 0.5, fill = "red") +
  theme_light() +
  theme(
    plot.margin =  unit(c(1, 1, 1, 1), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ylim(-0.60, 0.80) +
  xlab("Dyad Type") +
  ylab("Estimated R") +
  ggtitle("Estimated Pairwise Relatedness among Adult Dyads")

p
```

```{r Save Figure to PDF}
pdf(file = "figures/Estimated Pairwise Relatedness among Adult Dyads.pdf", width = 10, height = 8) # Export figure as PDF, 10" x 8"
p
dev.off()
```

```{r Testing Differences among Dyad Types}
# To test for differences in mean R among dyad types by permutation, we [1] shuffle each individual's sex, keeping the sample number of individuals per category, [2] assign a new "dyad_type" based on the shuffled sexes, and [3] recalculate mean R by dyad type for each replicate. We then compare the observed mean R for each dyad type and the differences between dyad types in mean R to the relevant permutation distribution.

set.seed(seed)

nperm <- 100000 # doing this many reps takes a long time...

reps_R <- tibble(
  FF = numeric(),
  MM = numeric(),
  MS = numeric())

for (i in 1:nperm) {
  # first, shuffle up sex for each adult individual
  shuffled.sex <- tibble(id = adults$ID, orig.sex = adults$SEX) %>%
    mutate(shuffled.sex = sample(orig.sex))
  # second, make a temp dataframe from pairwise_R...
  temp <- pairwise_R
  # ... and merge temp and shuffled.sex to get "new" sex for each individual
  temp <- inner_join(temp, shuffled.sex, by = c("ind1.id" = "id"))
  temp <- inner_join(temp, shuffled.sex, by = c("ind2.id" = "id"))
  temp <- temp %>% mutate(new.dyad.type = paste0(shuffled.sex.x, shuffled.sex.y))
  temp <- temp %>% mutate(new.dyad.type = case_when(
    new.dyad.type == "MF" | new.dyad.type == "FM" ~ "MS",
    new.dyad.type == "FF" ~ "FF",
    new.dyad.type == "MM" ~ "MM"))
  temp <- temp %>%
    group_by(new.dyad.type) %>%
    summarize(mean = mean(quellergt)) %>%
    pivot_wider(values_from = mean, names_from = new.dyad.type)
    reps_R <- bind_rows(reps_R, temp)
}

reps_R <- reps_R %>%
  mutate(
     MM.FF.diff = MM - FF,
     MM.MS.diff = MM - MS,
     FF.MS.diff = FF - MS) %>%
  pivot_longer(everything()) %>%
  rename(dyad.type = name, mean.R = value) %>%
  arrange(factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")))

# Calculate p values and critical values for observed statistics relative to permutation distribution

FF.p <- get_p_value(
  reps_R %>% filter(dyad.type == "FF") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "FF") %>% pull(obs.Mean.R),
  direction = "left")

FF.crit <- quantile(
  reps_R %>% filter(dyad.type == "FF") %>% pull(mean.R),
  0.05)

MS.p <- get_p_value(
  reps_R %>% filter(dyad.type == "MS") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "MS") %>% pull(obs.Mean.R),
  direction = "both")

MS.crit <- quantile(
  reps_R %>% filter(dyad.type == "MS") %>% pull(mean.R),
  c(0.025, 0.975))

MM.p <- get_p_value(
  reps_R %>% filter(dyad.type == "MM") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "MM") %>% pull(obs.Mean.R),
  direction = "right")

MM.crit <- quantile(
  reps_R %>% filter(dyad.type == "MM") %>% pull(mean.R),
  c(0.95))

FF.MS.diff.p <- get_p_value(
  reps_R %>% filter(dyad.type == "FF.MS.diff") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "FF.MS.diff") %>% pull(obs.Mean.R),
  direction = "both")

FF.MS.diff.crit <- quantile(
  reps_R %>% filter(dyad.type == "FF.MS.diff") %>% pull(mean.R),
  c(0.025, 0.975))

MM.MS.diff.p <- get_p_value(
  reps_R %>% filter(dyad.type == "MM.MS.diff") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "MM.MS.diff") %>% pull(obs.Mean.R),
  direction = "both")

MM.MS.diff.crit <- quantile(
  reps_R %>% filter(dyad.type == "MM.MS.diff") %>% pull(mean.R),
  c(0.025, 0.975))

MM.FF.diff.p <- get_p_value(
  reps_R %>% filter(dyad.type == "MM.FF.diff") %>% select(mean.R),
  obs_R %>% filter(dyad.type == "MM.FF.diff") %>% pull(obs.Mean.R),
  direction = "right")

MM.FF.diff.crit <- quantile(
  reps_R %>% filter(dyad.type == "MM.FF.diff") %>% pull(mean.R),
  c(0.95))

p.value <- bind_rows(FF.p, MS.p, MM.p, FF.MS.diff.p, MM.MS.diff.p, MM.FF.diff.p) %>% rename(p.value = p_value)

crit.value <- bind_rows(FF.crit, MS.crit, MM.crit, FF.MS.diff.crit, MM.MS.diff.crit, MM.FF.diff.crit)

# Collate results into a summary table

summary <- reps_R %>%
  group_by(dyad.type) %>%
  summarize(
    reps.Mean.R = mean(mean.R)
    ) %>%
  left_join(., obs_R, by = c("dyad.type" = "dyad.type")) %>%
  arrange(factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")))

summary <- bind_cols(summary, p.value, crit.value) %>%
  mutate(color = if_else(`p.value` < 0.05, "blue", "red"))
```

```{r Plot Results}
# Plot observed statistics relative to permutation distribution

p <- ggplot(data = reps_R, aes(x = mean.R)) +
  geom_histogram(bins = 25, aes(y = after_stat(density)), fill = "darkgrey") +
  geom_density(fill = "blue", alpha = 0.2) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  ggtitle("Expected Mean R by Dyad Class - Permuting Individual Sex") +
  xlab("Mean R") +
  ylab("Frequency") +
  theme_light() +
  theme(
    plot.margin =  unit(c(1, 1, 1, 1), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  geom_rect(
    data = summary,
    aes(xmin = `2.5%`, xmax = `97.5%`, ymin = 0, ymax = Inf),
    alpha = 0.5, fill = "grey",
    inherit.aes = FALSE) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_rect(
    data = summary,
    aes(xmin = `5%`, xmax = Inf, ymin = 0, ymax = Inf),
    alpha = 0.5, fill = "grey",
    inherit.aes = FALSE) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_rect(
    data = summary,
    aes(xmin = -Inf, xmax = `95%`, ymin = 0, ymax = Inf),
    alpha = 0.5, fill = "grey",
    inherit.aes = FALSE) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_vline(
    data = summary,
    aes(xintercept = obs.Mean.R), color = summary$color, linewidth = 1) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_vline(
      data = summary,
      aes(xintercept = `5%`), color = "black", linetype = "dotted", linewidth = 1) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_vline(
      data = summary,
      aes(xintercept = `2.5%`), color = "black", linetype = "dotted", linewidth = 1) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_vline(
      data = summary,
      aes(xintercept = `95%`), color = "black", linetype = "dotted", linewidth = 1) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free") +
  geom_vline(
    data = summary,
    aes(xintercept = `97.5%`),
    color = "black",
    linetype = "dotted",
    linewidth = 1) +
  facet_wrap(~ factor(dyad.type, levels = c("FF","MS","MM","FF.MS.diff","MM.MS.diff","MM.FF.diff")), scales = "free")

p
```

```{r Save Figure to PDF}
pdf(file = "figures/Expected Mean R by Dyad Class.pdf", width = 10, height = 8) # Export figure as PDF, 10" x 8"
p
dev.off()
```

# MHC Summary Statistics

We first want to summarize, for each male and female, the total number of MHC alleles they have. So, we read in two data files of raw MHC allele presence/absence data and calculate the total MHC diversity for each individual. These are two files with rows containing male or female IDs and columns scoring the presence/absence (1/0) of each of 22 MHC alleles.

```{r MHC Summary Statistics}
m <- "data/mhc_males.txt"
f <- "data/mhc_females.txt"

males.data <- read_table(m, col_names = TRUE)
males.data <- males.data %>%
  mutate(div = rowSums(across(where(is.numeric))))
# skim(males.data$div) # uncomment for quick visualization of summary stats
males.div <- males.data %>%
  select(ID, div)

females.data <- read_table(f, col_names = TRUE)
females.data <- females.data %>%
  mutate(div = rowSums(across(where(is.numeric))))
# skim(females.data$div) # uncomment for quick visualization of summary stats
females.div <- females.data %>%
  select(ID, div)
```

# Generate Diversity, Dissmilarity, and Relatedness Matrices

We now want to create several data sets we will need to test hypotheses.

The following snippet of code provides visualization of a toy example of how we summarize MHC allele diversity, sharing, dissimilarity, and uniqueness for a pair of individuals, say, female "A" and male "B"...

```{r Venn Diagram Example}
set.seed(seed)

alleles <- paste("MHC", 1:22, sep = "") # creates an array of different MHC alleles
x <- list(
  A = sample(alleles, 7), # select 7 alleles at random for individual A
  B = sample(alleles, 6) # select 6 alleles at random for individual A
  )
ggvenn( # Venn diagram of allelic overlap
  x, 
  fill_color = c("#0073C2FF", "#EFC000FF"),
  stroke_size = 0.5, set_name_size = 4
  )
```

Here, female "A" has seven different alleles and male "B" has six alleles. This is their allelic *diversity*. The overlap area represents allele *sharing* between female "A" and male "B" -- they have three alleles in common. The blue area represents alleles *unique* to female "A" (four alleles), the yellow area represents alleles *unique* to male "M" (three alleles), and the blue + yellow area, exclusive of the area of overlap, represents *dissimilarity* between female "A" and male "B", i.e., the total number of alleles present in the pair that they do not have in common (seven alleles).

## Diversity

To test H1, about MALE MHC DIVERSITY, we need a matrix consisting of a row for each female dam in the dataset and a column for each male, where cell values reflect each particular male's total number of MHC alleles, as calculated above. Note that all rows in this female X male matrix will have the same values.

```{r Male Diversity Matrix}
males.div <- males.div %>%
  column_to_rownames("ID") %>%
  as.matrix()
females.id <- column_to_rownames(females.data, "ID") %>%
  mutate(div = 1) %>%
  select(div) %>%
  as.matrix()
male.diversity <- females.id %*% t(males.div)
# This matrix now contains the total number of MHC alleles that each male (columns) has, repeated for each female (rows)
```

## Dissimilarity

To test H2, about DISSIMILARITY between males and females, we need to create matrices that summarize aspects of MHC ALLELE SHARING AND NONSHARING between dams and possible sires. Again, these matrices should consist of a row for each female dam in the population and a column for each male. Cell values for these matrices indicate the number of MHC alleles that the particular combination of dam and male have in common ("sharing"), do not have in common ("dissimilarity"), or are unique in one or the other sex "uniqueness".

We first reformat the tables summarizing MHC allele presence/absence (1/0) in males and females, respectively, into numeric data matrices where row attributes are individual IDs and columns attributes are the presence/absence (1/0) of each MHC allele. These matrixare useful for quickly constructing cross-tabulations for allele sharing and nonsharing for different pairs of individuals.

```{r Allele Presence/Absence Matrices}
males.alleles.matrix <- males.data %>%
  column_to_rownames("ID") %>%
  select(-div) %>%
  as.matrix()

females.alleles.matrix <- females.data %>%
  column_to_rownames("ID") %>%
  select(-div) %>%
  as.matrix()
```

Now, to get a matrix of MHC ALLELE SHARING values between all pairs of males and females, we use the matrix multiplication operator (%*%) to take the cross product of the female and (transposed) male 1/0 matrices, which results in a matrix of pairwise allele *sharing*, i.e., the number of shared alleles between each pair of female-male pair.

```{r Female-Male Allele Sharing Matrix}
sharing <- females.alleles.matrix %*% t(males.alleles.matrix)
# This matrix now contains the total number of MHC alleles shared between each combination of female (rows) and male (columns)
```

We create a matrix of MHC DISSIMILARITY between males and females, i.e., the total number of alleles present in each pair of female and male that they *do not* have in common, using the code below...

```{r Female-Male Dissimilarity Matrix}
dissimilarity <- ncol(females.alleles.matrix) -
  (!females.alleles.matrix) %*% t(!males.alleles.matrix) -
  females.alleles.matrix %*% t(males.alleles.matrix)
# this is now a dissimilarity matrix... the number of alleles present in either individual that not shared between each female (rows) and male (columns)
```

Finally, we also create a matrix of male "uniqueness" relative to each female, i.e., the total number of alleles a male has that each female does not, with the code below...

```{r Male Uniqueness Matrix}
male.uniqueness <- (!females.alleles.matrix) %*% t(males.alleles.matrix)
# This is now a matrix of how many alleles each male (columns) has that are different from those found in each particular female (rows)
```

## Relatedness

To test H3, about relatedness between dam-sire pairs, we need a matrix of pairwise estimated genetic relatedness that is structured similarly to those matrices created above, i.e., with females in rows and males in columns. We create this matrix using the matrix of adult pairwise R estimates we generated above.

```{r Female-Male Relatedness Matrix}
# Convert the matrix of adult pairwise R estimates that we created above to a "tibble", a special kind of data frame, which lets us manipulate it easily
relatedness <- as_tibble(adults_R_matrix)
ids <- names(relatedness)
relatedness <- bind_cols(ID = ids, relatedness)

# Get adult female and male IDs for all dams and potential sires
# Note that here there are 5 fewer females than in the "adults.txt" file and than in the "adults_genos.txt" file, because MHC diversity was only typed for dams and potential sire, not for the five additional adult females who were not dams
females <- females.data %>% pull(ID)
males <- males.data %>% pull(ID)

# Extract dam rows and potential sire columns from the relatedness matrix
relatedness <- relatedness %>%
  filter(ID %in% females) %>%
  select(c(ID, all_of(males)))

# Convert this "tibble" back to a matrix with female IDs in rows and male IDs in columns
relatedness <- column_to_rownames(relatedness, "ID")
relatedness <- as.matrix(relatedness)
# This is now a matrix of estimated R between each female (rows) and each male (columns) in the dataset
```

The dimensions of the five matrices we have just created -- sharing, male.diversity, dissimilarity, male.uniqueness, and relatedness -- should all be 27 females by 32 males.

# Simulations to Test Predictions

All simulations are based on the same number of replicates, set below.

```{r Set Number Replicates}
reps <- 100000
```

## H1 - MHC ALLELE DIVERSITY IN SIRES

To test H1, we want to compare average MHC diversity among actual sires to average diversity among a set of random possible sires for each offspring to examine whether females have offspring with males who have, on average, higher MHC diversity than expected by chance. For the relevant data are in the data in matrix "male.diversity" generated above.

However, we cannot just use this matrix as created because we need to take into account the fact that [1] some dams in the population had more than one offspring in our dataset and [2] that, for some offspring, certain males were not available as potential sires (e.g., because they were too young or were dead or otherwise not present at the time of a particular offspring's conception). Thus, we need to create an updated version of the "male.diversity" matrix that incorporates this additional demographic information about the availability of different males as potential sires.

We do this by first loading in a data table which has one row for each known dam-offspring dyad (based on parentage results) and one column for all adult males in the study population, where the cell values in this matrix are `1` if the male was considered a candidate sire for that particular offspring (i.e., if he was greater than 5 years of age and present in the group at the time of the offspring's conception) or `NA` if the male was not considered a candidate sire (i.e., he was too young or was dead).

```{r Demographic Overview Matrix}
overview <- read_tsv("data/parentage_and_candidates.txt", col_names = TRUE)
offspring <- overview %>% pull(OFFSPRING)
dams <- overview %>% pull(DAM)
sires <- overview %>% pull(SIRE)
candidates <- names(overview)[-3:-1] # all possible candidate sire names, which is equivalent to "males", generated above
overview <- as.matrix(overview[, 4:ncol(overview)]) # subset and convert to matrix...
dimnames(overview) = list(dams, candidates) # assign dam name as rowname

# This is now a matrix containing information on whether each male was considered a candidate sire or not for each of the 47 offspring in the data, with dam ID as the rowname and candidate sire ID as the column name
```

We then extract from the appropriate value from the original male.diversity matrix for each combination of dam and male for only those cells where the value is `1`.

```{r Updated Male Diversity Matrix}
# Create an empty matrix that we will fill with appropriate values
male.diversity.updated <- matrix(NA, nrow = length(dams), ncol = length(males), dimnames = list(dams, males))

# Extract values from male.diversity only where the overview matrix indicates a male could be a potential sire of each dams' offspring
for (i in 1:nrow(overview)) {
  for (j in dimnames(male.diversity.updated)[[2]]) {
    male.diversity.updated[i,j] <- overview[i,j] * male.diversity[rownames(male.diversity.updated)[[i]], j]
  }
}

# To save this data structure...
male.diversity.updated %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/male.diversity.matrix.txt")
```

This matrix now contains, for each of 47 offspring, a unique combination of dam + offspring as rows, all male IDs as columns, and, as cell values, the number of MHC alleles carried by each potential sire, with cells only filled in if the male could have potentially sired the given offspring.

Now we sample, for each row in the data matrix a random column (male) to generate a set of N = 47 actual dam + random potential sire pairs. This is repeated `reps` times, and for each replicate, we calculate the mean number of alleles that "sires" have across this set of 47 offspring. The `!is.na` in the apply() function line in the simulation means that we can only sample a male as random sire if the data for him is not `NA`.

The result of each simulation is the average MHC allelic diversity across 47 simulated sires, and `sim.male.divervsity$stat` is thus a null distribution of average male MHC diversity scores across random sets of sires.

```{r Male Diversity Simulation}
set.seed(seed)

sim.male.diversity <- replicate(
  reps,
  apply(male.diversity.updated, 1, function(x) sample(x[!is.na(x)], 1))
  ) %>%
  t() %>%
  as_tibble() %>% 
  mutate(replicate = row_number()) %>%
  pivot_longer(cols = -c(replicate)) %>%
  group_by(replicate) %>%
  summarize(stat = mean(value))
```

Next, we calculate the observed average male MHC diversity among known sires and compare to this the critical value derived from the simulation distribution. To calculate the observed average, we simply pull out the relevant values from the "male.diversity" matrix...

```{r Observed Mean Male Diversity}
# Extract values to calculate observed male MHC diversity in pairs that we know actually had kids together and calculate the average

male.diversity.obs <- vector() # vector to hold results
for (i in 1:length(offspring)) {
  male.diversity.obs[i] <- male.diversity[dams[i], sires[i]]
}

mean.male.diversity = mean(male.diversity.obs)
```

Because we are testing the one-tailed hypothesis of higher allelic diversity among the set of actual sires than random sires, the critical value of interest corresponds to the 95th quantile of the simulation distribution.

The associated p value is simply the proportion of simulation runs where the average diversity among sets of random sires exceeds that among observed in the set of real sires.

```{r Critical Value and P Value}

(male.diversity.crit.val <- quantile(sim.male.diversity$stat, c(0.95)))

(p.val <- sum(sim.male.diversity$stat > mean.male.diversity)/reps)
```

```{r Plot Results}
male.diversity.plot <- ggplot(
  data = sim.male.diversity, aes(stat)) +
  geom_histogram(
    aes(y = after_stat(density)),
    fill = "darkgrey",
    binwidth = 0.05,
    center = mean(sim.male.diversity$stat)) +
  geom_density(
    fill = "blue", alpha = 0.2) +
  theme_light() +
  theme(
    plot.margin =  unit(c(1, 0, 0, 1), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ggtitle("MHC Diversity among Sires") +
  xlab("Mean Number of Alleles") +
  ylab("Frequency") +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1, decimal.mark = '.')) +
  geom_vline(xintercept = mean.male.diversity, col = "blue" ,linewidth = 1) +
  geom_vline(xintercept = male.diversity.crit.val, linetype = "dotted", color = "black", linewidth = 1) +
  annotate("rect", xmin = -Inf, xmax = male.diversity.crit.val, ymin = 0, ymax = Inf, alpha = 0.2, fill = "grey")

male.diversity.plot
```

## H2 - MHC DISSMILARITY and UNIQUENESS

One way look at whether dam-sire pairs reflect disassortative mating is to do a similar simulation using the *dissimilarity* dataset. To do this, we need to create an updated version of the "dissimilarity" data matrix that, as above, duplicates lines corresponding to additional offspring for each female and has `NA`s in cells for where an given male could not be a potential sire for the offspring in question, based on longitudinal demographic data. The process to create this updated matrix is the same as followed above.

```{r Updated Dissimilarity Matrix}
# Create an empty matrix that we will fill with appropriate values
dissimilarity.updated <- matrix(NA, nrow = length(dams), ncol = length(males), dimnames = list(dams, males))

# Extract values from male.dissimilarity only where the overview matrix indicates a male could be a potential sire of each dams' offspring
for (i in 1:nrow(overview)) {
  for (j in dimnames(dissimilarity.updated)[[2]]) {
    dissimilarity.updated[i,j] <- overview[i,j] * dissimilarity[rownames(dissimilarity.updated)[[i]], j]
  }
}

# To save this data structure...
dissimilarity.updated %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/dissimilarity.matrix.txt")
```

This matrix now contains, for each of 47 offspring, a unique combination of dam + offspring as rows, all male IDs as columns, and, as cell values, the number of MHC alleles possessed by a given female-male pair that they *do* not have in common. Cells are only filled with a value if the male in question (column) could have potentially sired the offspring represented in each dam-offspring row.

Now we again sample, for each row in the data matrix a random column (male) to generate a set of N = 47 actual dam + random potential sire pairs. This is repeated `reps` times, and for each replicate, we calculate the mean dissimilarity between dam and sire across this set of 47 offspring. `sim.dissimilarity$stat` is thus a null distribution of average dam-sire dissimilarity scores across random sets of sires.

```{r Female-Male Dissimilarity Simulation}
set.seed(seed)

sim.dissimilarity <- replicate(
  reps,
  apply(dissimilarity.updated, 1, function(x) sample(x[!is.na(x)], 1))
  ) %>%
  t() %>%
  as_tibble() %>% 
  mutate(replicate = row_number()) %>%
  pivot_longer(cols = -c(replicate)) %>%
  group_by(replicate) %>%
  summarize(stat = mean(value))
```

We extract observed allelic dissimilarity among actual dam-sire pairs by pulling the relevant data from the "dissimilarity" matrix and calculate the average of these values...

```{r Observed Mean Female-Male Dissimilarity}
dissimilarity.obs <- vector()
for (i in 1:length(offspring)) {
  dissimilarity.obs[i] <- dissimilarity[dams[i], sires[i]]
}

mean.dissimilarity = mean(dissimilarity.obs)
```

Because we are testing the one-tailed hypotheses of greater allelic dissimilarity among the set of dam-actual sire pairs than among dam-random sire pairs, the critical value of interest corresponds to the 95th quantile of the simulation distribution.

The associated p value is simply the proportion of simulation runs where the average dissimilarity among sets of random sires exceeds that among observed in the set of real sires.

```{r Critical Value and P Value}
(dissimilarity.crit.val <- quantile(sim.dissimilarity$stat, c(0.95)))

(p.val <- sum(sim.dissimilarity$stat > mean.dissimilarity)/reps)
```

```{r Plot Results}
dissimilarity.plot <- ggplot(
  data = sim.dissimilarity, aes(stat)) +
  geom_histogram(aes(y = after_stat(density)), fill = "darkgrey", binwidth = 0.075, center = mean(sim.dissimilarity$stat)) +
  geom_density(fill = "blue", alpha = 0.2) +
  theme_light() +
  theme(
    plot.margin =  unit(c(1, 1, 0, 0), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ggtitle("Dam-Sire Allelic Dissimilarity") +
  xlab("Mean Number of Alleles") +
  ylab("Frequency") +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1, decimal.mark = '.')) +
  geom_vline(xintercept = mean.dissimilarity, col = "red" ,linewidth = 1) +
  geom_vline(xintercept = dissimilarity.crit.val, linetype = "dotted", color = "black", linewidth = 1) +
  annotate("rect", xmin = -Inf, xmax = dissimilarity.crit.val, ymin = 0, ymax = Inf, alpha = 0.2, fill = "grey")

dissimilarity.plot
```

As a second test relevant to this hypothesis, we can also examine whether dams have offspring with sires that have a greater number of *unique* MHC alleles relative to themselves. For this we would use the data in matrix "male.uniqueness", again updating that matrix to take into account the fact that some females had more than one offspring in our dataset and that, for some offspring, certain males were not available as potential sires.

```{r Updated Male Uniqueness Matrix}
# Create an empty matrix that we will fill with appropriate values
male.uniqueness.updated <- matrix(NA, nrow = length(dams), ncol = length(males), dimnames = list(dams, males))

# Extract values from male.uniqueness only where the overview matrix indicates a male could be a potential sire of each dams' offspring
for (i in 1:nrow(overview)) {
  for (j in dimnames(male.uniqueness.updated)[[2]]) {
    male.uniqueness.updated[i,j] <- overview[i,j] * male.uniqueness[rownames(male.uniqueness.updated)[[i]], j]
  }
}

# To save this data structure...
male.uniqueness.updated %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/male.uniqueness.matrix.txt")
```

We then run an analogous simulation to those above. This time, the result of each simulation is the average number of unique alleles among each set of simulated sires, and the null distribution of this statistic is held in `sim.male.uniqueness$stat`.

```{r Male Uniqueness Simulation}
set.seed(seed)

sim.male.uniqueness <- replicate(
  reps,
  apply(male.uniqueness.updated, 1, function(x) sample(x[!is.na(x)], 1))
  ) %>%
  t() %>%
  as_tibble() %>% 
  mutate(replicate = row_number()) %>%
  pivot_longer(cols = -c(replicate)) %>%
  group_by(replicate) %>%
  summarize(stat = mean(value))
```

As above, we extract observed uniquess among actual sires relative to dams by pulling the relevant data from the "male.uniqueness" matrix and calculating the average of these values...

```{r Observed Mean Male Uniqueness}
male.uniqueness.obs <- vector()
for (i in 1:length(offspring)) {
  male.uniqueness.obs[i] <- male.uniqueness[dams[i], sires[i]]
}

mean.male.uniqueness <- mean(male.uniqueness.obs)
```

Because we are testing the one-tailed hypotheses of higher allelic uniquness among the set of dam-actual sire pairs than among dam-random sire pairs, the critical value of interest corresponds to the 95th quantile of the simulation distribution.

The associated p value is simply the proportion of simulation runs where the average male uniqueness among sets of random sires exceeds that among observed in the set of real sires.

```{r Critical Value and P Value}
(male.uniqueness.crit.val <- quantile(sim.male.uniqueness$stat, c(0.95)))

(p.val <- sum(sim.male.uniqueness$stat > mean.male.uniqueness)/reps)
```

```{r Plot Results}
male.uniqueness.plot <- ggplot(
  data = sim.male.uniqueness, aes(stat)) +
  geom_histogram(aes(y = after_stat(density)), fill = "darkgrey", binwidth = 0.075, center = mean(sim.male.uniqueness$stat)) +
  geom_density(fill = "blue", alpha = 0.2) +
  theme_light() +
  theme(
    plot.margin =  unit(c(0, 0, 1, 1), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ggtitle("MHC Uniqueness among Sires") +
  xlab("Mean Number of Alleles") +
  ylab("Frequency") +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1, decimal.mark = '.')) +
  geom_vline(xintercept = mean.male.uniqueness, col = "red" ,linewidth = 1) +
  geom_vline(xintercept = male.uniqueness.crit.val, linetype = "dotted", color = "black", linewidth = 1) +
  annotate("rect", xmin = -Inf, xmax = male.uniqueness.crit.val, ymin = 0, ymax = Inf, alpha = 0.2, fill = "grey")

male.uniqueness.plot
```

## H3 - Relatedness and Kinship

Here, we examine whether dam-actual sire pairs are more or less closely related, on average, than dam-random sire pairs. As above, we first create an updated "relatedness" data matrix that duplicates lines corresponding to additional offspring for each female and has `NA`s in cells for where an given male could not be a potential sire for the offspring in question,

```{r Updated Relatedness Matrix}
# Create an empty matrix that we will fill with appropriate values
relatedness.updated <- matrix(NA, nrow = length(dams), ncol = length(males), dimnames = list(dams, males))

# Extract values from relatedness only where the overview matrix indicates a male could be a potential sire of each dams' offspring

for (i in 1:nrow(overview)) {
  for (j in dimnames(relatedness.updated)[[2]]) {
    relatedness.updated[i,j] <- overview[i,j] * relatedness[rownames(relatedness.updated)[[i]], j]
  }
}

# To save this data structure...
relatedness.updated %>%
  as.data.frame() %>%
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  write_tsv(file = "outputs/relatedness.matrix.txt")
```

We then run another analogous simulation to those above. This time, the result of each simulation is the average relatedness among each set of dams + simulated sires, and the null distribution of this statistic is held in `sim.relatedness$stat`.

```{r Relatedness Simulation}
set.seed(seed)

sim.relatedness <- replicate(
  reps,
  apply(relatedness.updated, 1, function(x) sample(x[!is.na(x)], 1))
  ) %>%
  t() %>%
  as_tibble() %>% 
  mutate(replicate = row_number()) %>%
  pivot_longer(cols = -c(replicate)) %>%
  group_by(replicate) %>%
  summarize(stat = mean(value))
```

As above, we extract observed relatedness among actual dam-sire pairs by pulling the relevant data from the "relatedness" matrix and calculating the average of these values...

```{r Observed Mean Female-Mean Relatedness}
# Extract values to calculate observed mean relatedness between mated pairs

relatedness.obs <- vector()
for (i in 1:length(offspring)) {
  relatedness.obs[i] <- relatedness[dams[i], sires[i]]
}

mean.relatedness = mean(relatedness.obs)
```

Because we are testing the one-tailed hypothesis of lower relatedness among the set of dam-actual sire pairs than among dam-random sire pairs, the critical value of interest corresponds to the 5th quantile of the simulation distribution.

The associated p value is simply the proportion of simulation runs where the average relatedness among random dam-sire pairs is less than that among real pairs.

```{r Critical Value and P Value}
(relatedness.crit.val <- quantile(sim.relatedness$stat, c(0.05)))

(p.val <- sum(sim.relatedness$stat < mean.relatedness)/reps)
```

```{r Plot Results}
relatedness.plot <- ggplot(data = sim.relatedness, aes(stat)) +
  geom_histogram(aes(y = after_stat(density)), fill = "darkgrey", binwidth = 0.01, center = mean(sim.relatedness$stat)) +
  geom_density(fill = "blue", alpha = 0.2) +
  theme_light() +
  theme(
    plot.margin =  unit(c(0, 1, 1, 0), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ggtitle("Dam-Sire Relatedness") +
  xlab("Mean Estimated R") +
  ylab("Frequency") +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1, decimal.mark = '.')) +
  geom_vline(xintercept = relatedness.crit.val, linetype = "dotted", color = "black", linewidth = 1) +
  geom_vline(xintercept = mean.relatedness, col = "red", linewidth = 1) +
  annotate("rect", xmin = relatedness.crit.val, xmax = Inf, ymin = 0, ymax = Inf, alpha = 0.2, fill = "grey")

relatedness.plot
```

```{r Save Combined Figure to PDF}
pdf(file = "figures/Figure 1.pdf", width = 10, height = 8) # Export figure as PDF, 10" x 8"
plot_grid(male.diversity.plot, dissimilarity.plot, male.uniqueness.plot, relatedness.plot, nrow = 2, ncol = 2, align = c("hv"), axis = "lr", labels = c("A.", "B.", "C.", "D."))
dev.off()
```

## Simulating First- and Second-Order Kin

```{r Generate PO FS HS and UN Genotypes Using the {related} Package}
set.seed(seed)

# Start with the set of adult genotypes...
sim <- familysim(adults_genos$freqs, 100)
sim.fam <- coancestry(sim, error.rates = 0.01, quellergt = 2)
sim.fam <- cleanuprvals(sim.fam$relatedness, 100)
rel.values <- sim.fam[, c("quellergt")]
label1 <- rep("Parent-Offspring", 100)
label2 <- rep("Full Siblings", 100)
label3 <- rep("Half Siblings", 100)
label4 <- rep("Unrelated", 100)
labels <- c( label1 , label2 , label3 , label4 )
sim.rel <- tibble(rel = rel.values, dyad_type = c(labels))

p <- ggplot(data = sim.rel, aes(x = dyad_type, y = rel)) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.5) +
  theme_light() +
  theme(
    plot.margin =  unit(c(1, 1, 1, 1), "cm"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
    axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
    plot.title = element_text(size = 15, hjust = 0.0)
  ) +
  ylab("R Value") +
  xlab("Kinship Category") +
  ggtitle("Distribution of R Values among Simulated Kin Classes")

p

write_tsv(sim.rel, "outputs/simulated_relatedness_values_kin.csv") # based on only adult genotypes from {related}
```

```{r Calculate Mean R among Sets of Dyads of Different Kin Classes}
# Draw sets of random samples of 47 dyads of each dyad type and calculate mean R

nperm <- 10000
set.seed(seed)

sim.res <- tibble(
  `Mean PO` = numeric(),
  `Mean FS` = numeric(),
  `Mean HS` = numeric(),
  `Mean UN` = numeric())
for (i in 1:nperm) {
  temp <- sim.rel %>%
    group_by(dyad_type) %>%
    slice_sample(n = 47, replace = TRUE) %>%
    summarize(`Mean R` = mean(rel)) %>%
    mutate(dyad_type = case_when(
      dyad_type == "Parent-Offspring" ~ "Mean PO",
      dyad_type == "Full Siblings" ~ "Mean FS",
      dyad_type == "Half Siblings" ~ "Mean HS", 
      dyad_type == "Unrelated" ~ "Mean UN")) %>%
    pivot_wider(names_from = dyad_type, values_from = `Mean R`)
  sim.res <- bind_rows(sim.res, temp)
}

sim.res <- sim.res %>%
  pivot_longer(everything(), names_to = "dyad.type", values_to = "mean.R")
```

```{r Calculate Mean R among Actual Dam-Sire Pairs}
# First, find dam-sire pairs from parentage data
# Read in parentage data again and merge with pairwise_R
overview <- read_tsv("data/parentage_and_candidates.txt", col_names = TRUE)
parents <- overview %>%
  mutate(PAIR = paste0(DAM, "=" , SIRE)) %>%
  select(OFFSPRING, DAM, SIRE, PAIR)

pairwise_R <- pairwise_R %>%
  mutate(PAIR = paste0(`ind1.id`,"=",`ind2.id`)) %>% dplyr::select(PAIR, quellergt)

temp <- left_join(parents, pairwise_R, by = c("PAIR" = "PAIR"))
temp <- temp %>% mutate(PAIR = if_else(is.na(quellergt), paste0(SIRE, "=", DAM), PAIR))
temp <- temp %>% dplyr::select(-c(quellergt))
temp <- left_join(temp, pairwise_R, by = c("PAIR" = "PAIR"))

dam_sire <- temp %>%
  mutate(dyad.type = "Dam-Sire") %>%
  rename(obs.R = quellergt) %>%
  dplyr::select(dyad.type, obs.R, PAIR)

mean_dam_sire <- mean(dam_sire$obs.R) # mean observed R among dam-sire pairs
```

```{r Bootstrap to Get Distribution of Expected Mean R among Dam-Sire Pairs}
# Results of this simulation to be added to those for first- and second-order kin classes
dam_sire_boot <- tibble( # tibble to hold each bootstrap result
  dyad.type = factor(),
  mean.R = numeric())

nperm <- 10000
set.seed(seed)

for (i in 1:nperm) {
  perm <- dam_sire %>%
    slice_sample(prop = 1, replace = TRUE) %>%
    summarize(mean.R = mean(obs.R)) %>%
    mutate(dyad.type = "Mean DS") %>%
    dplyr::select(dyad.type, mean.R)
  dam_sire_boot <- bind_rows(dam_sire_boot, perm)
}

full.sim.res <- bind_rows(sim.res, dam_sire_boot) # join together simulation results for first- and second-order kin with those for dams-sires

full.sim.res$dyad.type <- factor(full.sim.res$dyad.type, levels = c("Mean PO", "Mean FS", "Mean HS", "Mean UN", "Mean DS")) # relevel for plotting

full.sim.res <- full.sim.res %>% arrange(dyad.type)

write_tsv(full.sim.res, "outputs/simulation_results.csv") # based on only adult genotypes from {related}
```

```{r}
close_kin_among_ds <- highlight_df %>% # this comes from kinship_code_for_muriqui_MHC
  mutate(dyad = "Dam-Sire") 
close_kin_among_ds <- left_join(
  close_kin_among_ds, dam_sire, by = c("dyad" = "dyad", "pair" = "pair"))

(p4 <- ggplot(data = full.sim.res, aes(x = mean.R)) +
  geom_histogram(bins = 50) +
  facet_wrap(~dyad.type, scales = "free"))

(p4a <- ggplot(data = full.sim.res, aes(x = dyad.type, y = mean.R)) +
  geom_violin() +
  geom_boxplot(width = 0.2) +
  xlab("Dyad Type") +
  ylab("Estimated R") +
  ggtitle("Distribution of Mean R Values for Simulated Sets\nof Kin Dyads + Bootstrapped Dam-Sire Mean R") +
    theme_light() +
    theme(
      plot.margin =  unit(c(0.5, 1, 1, 1), "cm"),
      axis.title = element_text(size = 13),
      axis.text = element_text(size = 11),
      axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
      axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
      plot.title = element_text(size = 14, hjust = 0)
    ) +
  ylim(-0.4, 0.7)
  )

(p4b <- ggplot(data = dam_sire, aes(x = dyad.type, y = obs.R)) +
    geom_boxplot(width = 0.2) +
    geom_point() +
    xlab("Dyad Type") +
    ylab("Estimated R") +
    ggtitle("Estimated Relatedness\namong Dam-Sire Pairs") +
    # geom_point(data = close_kin_among_ds, aes(x = dyad.type, y = obs.R), color = "black", size = 4, shape = 23, fill = "red", alpha = 0.8) +
    theme_light() +
    theme(
      plot.margin =  unit(c(0.5, 1, 1, 1), "cm"),
      axis.title = element_text(size = 13),
      axis.text = element_text(size = 11),
      axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)),
      axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
      plot.title = element_text(size = 14, hjust = 0)
    ) +
    ylim(-0.4, 0.7)
  ) 

plot_grid(p4a, p4b, align = "v", rel_widths = c(2,1.5), labels = c("A.", "B."))

po <- sim.res %>% filter(dyad.type == "Mean PO")
fs <- sim.res %>% filter(dyad.type == "Mean FS")
hs <- sim.res %>% filter(dyad.type == "Mean HS")
un <- sim.res %>% filter(dyad.type == "Mean UN")

(p_value <- (sum(po$mean.R <= abs(mean_dam_sire)) + sum(-1 * po$mean.R >= -1 * abs(mean_dam_sire))) / nperm)

(p_value <- (sum(fs$mean.R <= abs(mean_dam_sire)) + sum(-1 * fs$mean.R >= -1 * abs(mean_dam_sire))) / nperm)

(p_value <- (sum(hs$mean.R <= abs(mean_dam_sire)) + sum(-1 * hs$mean.R >= -1 * abs(mean_dam_sire))) / nperm)

(p_value <- (sum(un$mean.R <= abs(mean_dam_sire) | -1 * un$mean.R >= -1 * abs(mean_dam_sire))) / nperm)
```
